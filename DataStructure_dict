# 字典和集合的索引原理-数据结构层面
1.经验得出字典和集合的速度是非常快的
	建立一个有1000万个浮点数的容器A
	再建立一个1000个浮点数的容器B，其中有500个浮点数是在A中的，另外500个浮点数不再A中
现在我们试着执行一段代码来统计容器B在容器A中的浮点数的个数（结果为500）
	count = 0
	for I in B:
		if I in A:
			count += 1
用dict,set,list分别作为容器来测试一下代码执行效率
集合可以采用交集的形式
	count = len(A & B)

经过测试
速度最快的是采用了交集形式的集合set
次之是字典dict
最慢的是列表
主要原因是因为dict和set是利用散列表来支持in运算符，而list没有散列表，每次执行in运算符必须重新扫描一次完整的列表导致时间因根据数据大小成线性增长

2.字典索引原理---散列值
我们先讨论字典的内部结构，然后再延伸到集合上。

散列表实际上是一个稀疏数组（总有空白元素的数组称为稀疏数组）。
一般把散列表里的单元叫做表元，在dict的散列表中，每个键值对占用一个表元，每个表元有两部分，一个是对键的引用，一个是对值的引用。
因为表元大小一致，所以可以通过偏移量来读取某个表元。

python会设法保证有三分之一的表元是空的，当快要到达阈值时会把原有的散列表复制到一个更大的空间里。

要把一个对象放入散列表，必须要计算这个元素的散列值，可以用hash()方法来获取。下面会讨论这一点。

2.1散列值和相等性
内置hash()方法可以用于所有内置类型对象。如果是自定义对象调用hash()的话，实际上是运行的__hash__方法。
如果两个对象是相等的，那么他们的散列值必须相等，否则散列表不能正常运行。例如1 == 1.0为真，hash(1) == hash(1.0)也为真，但是这两个数字内部结构是不一样的(整数和浮点的区别)。
散列值会在索引空间中尽量分散开来，理想状况下，如实相似但不相等的角色，他们的散列值差别就越大。

1和1.0散列值相同但和1.0001，1.0002，1.0003差别很大。

2.2散列表算法
如要获取my_dict[search_key]的值，python会先调用hash(search_key)来计算search_key的散列值，然后把这个值的最后几位（根据散列表大小决定）作为偏移量去散列表里查找表元。
表元里有一对found_key:found_value
如果表元是空的，则抛出KeyError异常。
如果不是空的，则会检验search_key == found_key是否为True，如果为True，就返回found_value。
如果为False，则会发生散列冲突。原因是散列表实质上是把随机的元素映射到只有几位的数字上而散列表本身的索引只依赖于这几位数字。也就是说散列表只通过散列值的几位数字去查找对应表元，可能会查找到多个表元。
解决散列冲突的办法是算法会在散列值中再取几位，用特殊方法处理一下，把得到的新数字当作索引寻找表元。重复上述步骤直到抛出KeyError或者返回foun_value。


添加新元素和修改现有的键值操作几乎和上面一样。发现空表元就添加新元素，找到对应表元进行替换就可以了。

在插入新元素时，python可能会根据散列表的拥挤程度来决定是否重新分配内存来扩容，增加了散列表的大小，散列值所占位数和用作索引的位数都会增加，目的是为了减少散列冲突发生的概率。

3.dict的优点和缺点
3.1键必须是可散列的
可散列对象需满足的要求：
支持hash()，通过__hash__()方法得到的散列值不变
支持通过__eq__()方法检查相等性
a==b为真，则hash(a)--hash(b)为真。

所有用户自定义的对象默认都是可散列的，他们的散列值由id()获取(即id()的返回值)。

3.2 字典内存占用巨大
因为散列表是稀疏的，所以字典空间占用大。
如果需要存放数量巨大的记录，可以选择元组或者具名元组构成的列表中。
最好不要用字典组成的列表存放这些记录（JSON风格）。

如果你的服务器空间足够大，那么空间优化可以等到需要的时候再开始，因为优化往往是可维护性的对立面。

3.3键查询很快
字典虽然空间占用大，但是它能提供无视数据量大小的快速访问（只要在内存中）

3.4键的次序取决于添加顺序
当往字典里添加新键（新元素）时发生了散列冲突，那么新键可能会被存放在另一个位置。
即是说两个字典中数据内容一样，但是键的次序不同，这两个字典仍是相等的。

3.5 往字典里添加新键可能会改变已有键的顺序
任何时候往字典里添加新键（新元素），python都有可能会对字典进行扩容，新键一个更大的散列表，把字典里所有元素添加到新表李。这个过程可能会发生新的散列冲突，导致新的散列表中键的次序发生变化。
因此在遍历一个字典的过程中如果对字典进行修改，可能会导致迭代字典时跳过一些键。

4.set的优点和缺点
set和frozenset的实现也依赖散列表，它们的散列表中存放的只有元素的引用（类似于字典中没有值的键）。
字典和散列表的特点，对集合来说几乎适用。

4.1集合里的元素必须是可散列的。
4.2集合也很消耗内存。
4.3可以很高效的查询集合中的元素。
4.4元素的次序取决于被添加到集合里的次序。
4.5往集合里添加元素，可能会改变集合里已有元素的次序。
