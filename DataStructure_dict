# 字典和集合的索引原理-数据结构层面
1.经验得出字典和集合的速度是非常快的
	建立一个有1000万个浮点数的容器A
	再建立一个1000个浮点数的容器B，其中有500个浮点数是在A中的，另外500个浮点数不再A中
现在我们试着执行一段代码来统计容器B在容器A中的浮点数的个数（结果为500）
	count = 0
	for I in B:
		if I in A:
			count += 1
用dict,set,list分别作为容器来测试一下代码执行效率
集合可以采用交集的形式
	count = len(A & B)

经过测试
速度最快的是采用了交集形式的集合set
次之是字典dict
最慢的是列表
主要原因是因为dict和set是利用散列表来支持in运算符，而list没有散列表，每次执行in运算符必须重新扫描一次完整的列表导致时间因根据数据大小成线性增长

2.字典索引原理---散列值
我们先讨论字典的内部结构，然后再延伸到集合上。

散列表实际上是一个稀疏数组（总有空白元素的数组称为稀疏数组）。
一般把散列表里的单元叫做表元，在dict的散列表中，每个键值对占用一个表元，每个表元有两部分，一个是对键的引用，一个是对值的引用。
因为表元大小一致，所以可以通过偏移量来读取某个表元。

python会设法保证有三分之一的表元是空的，当快要到达阈值时会把原有的散列表复制到一个更大的空间里。

要把一个对象放入散列表，必须要计算这个元素的散列值，可以用hash()方法来获取。下面会讨论这一点。

2.1散列值和相等性
内置hash()方法可以用于所有内置类型对象。如果是自定义对象调用hash()的话，实际上是运行的__hash__方法。
如果两个对象是相等的，那么他们的散列值必须相等，否则散列表不能正常运行。例如1 == 1.0为真，hash(1) == hash(1.0)也为真，但是这两个数字内部结构是不一样的(整数和浮点的区别)。
散列值会在索引空间中尽量分散开来，理想状况下，如实相似但不相等的角色，他们的散列值差别就越大。

1和1.0散列值相同但和1.0001，1.0002，1.0003差别很大。

2.2散列表算法
如要获取my_dict[search_key]的值，python会先调用hash(search_key)来计算search_key的散列值，然后把这个值的最后几位（根据散列表大小决定）作为偏移量去散列表里查找表元。
表元里有一对found_key:found_value
如果表元是空的，则抛出KeyError异常。
如果不是空的，则会检验search_key == found_key是否为True，如果为True，就返回found_value。
如果为False，则会发生散列冲突。原因是散列表实质上是把随机的元素映射到只有几位的数字上而散列表本身的索引只依赖于这几位数字。也就是说散列表只通过散列值的几位数字去查找对应表元，可能会查找到多个表元。
解决散列冲突的办法是算法会在散列值中再取几位，用特殊方法处理一下，把得到的新数字当作索引寻找表元。重复上述步骤直到抛出KeyError或者返回foun_value。


添加新元素和修改现有的键值操作几乎和上面一样。发现空表元就添加新元素，找到对应表元进行替换就可以了。

在插入新元素时，python可能会根据散列表的拥挤程度来决定是否重新分配内存来扩容，增加了散列表的大小，散列值所占位数和用作索引的位数都会增加，目的是为了减少散列冲突发生的概率。

3.dict的优点和缺点
3.1键必须是可散列的
可散列对象需满足的要求：
支持hash()，通过__hash__()方法得到的散列值不变
支持通过__eq__()方法检查相等性
a==b为真，则hash(a)--hash(b)为真。
